--- a/arch/arm/mach-hisi/platsmp.c
+++ b/arch/arm/mach-hisi/platsmp.c
@@ -20,6 +20,48 @@
 
 static void __iomem *ctrl_base;
 
+/*
+ * hisi_pen_release controls the release of CPUs from the holding
+ * pen in headsmp.S, which exists because we are not always able to
+ * control the release of individual CPUs from the board firmware.
+ */
+volatile int hisi_pen_release = -1;
+
+/*
+ * Write hisi_write_pen_release in a way that is guaranteed to be visible to
+ * all observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void hisi_write_pen_release(int val)
+{
+	hisi_pen_release = val;
+	smp_wmb();
+	sync_cache_w(&hisi_pen_release);
+}
+
+/*
+ * hisi_lock exists to avoid running the loops_per_jiffy delay loop
+ * calibrations on the secondary CPU while the requesting CPU is using
+ * the limited-bandwidth bus - which affects the calibration value.
+ */
+static DEFINE_RAW_SPINLOCK(hisi_lock);
+
+static void hisi_pen_secondary_init(unsigned int cpu)
+{
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	hisi_write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	raw_spin_lock(&hisi_lock);
+	raw_spin_unlock(&hisi_lock);
+}
+
+
 void hi3xxx_set_cpu_jump(int cpu, void *jump_addr)
 {
 	cpu = cpu_logical_map(cpu);
@@ -182,6 +224,87 @@ static const struct smp_operations hip01
 	.smp_boot_secondary     = hip01_boot_secondary,
 };
 
+
+static void hi3798_smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int i;
+	unsigned int l2ctlr;
+	unsigned int ncores;
+
+	asm ("mrc p15, 1, %0, c9, c0, 2\n" : "=r" (l2ctlr));
+	ncores = ((l2ctlr >> 24) & 0x3) + 1;
+
+	pr_info("smp: %u cores detected\n", ncores);
+	if (ncores > max_cpus) {
+		pr_warn("smp: %u cores greater than maximum (%u), clipping\n",
+			ncores, max_cpus);
+		ncores = max_cpus;
+	}
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	/* Put the boot address in this magic register */
+	hix5hd2_set_scu_boot_addr(HIX5HD2_BOOT_ADDRESS,
+				  __pa_symbol(hisi_secondary_startup));
+}
+
+static int hi3798_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	raw_spin_lock(&hisi_lock);
+
+	hi3798_set_cpu(cpu, true);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	hisi_write_pen_release(cpu);
+
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (hisi_pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	raw_spin_unlock(&hisi_lock);
+
+	return hisi_pen_release != -1 ? -ENOSYS : 0;
+}
+
+static const struct smp_operations hi3798_smp_ops __initconst = {
+	.smp_prepare_cpus	= hi3798_smp_prepare_cpus,
+	.smp_secondary_init	= hisi_pen_secondary_init,
+	.smp_boot_secondary	= hi3798_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= hi3798_cpu_die,
+	.cpu_kill		= hi3798_cpu_kill,
+#endif
+};
+
+
 CPU_METHOD_OF_DECLARE(hi3xxx_smp, "hisilicon,hi3620-smp", &hi3xxx_smp_ops);
 CPU_METHOD_OF_DECLARE(hix5hd2_smp, "hisilicon,hix5hd2-smp", &hix5hd2_smp_ops);
 CPU_METHOD_OF_DECLARE(hip01_smp, "hisilicon,hip01-smp", &hip01_smp_ops);
+CPU_METHOD_OF_DECLARE(hi3798_smp, "hisilicon,hi3798-smp", &hi3798_smp_ops);
